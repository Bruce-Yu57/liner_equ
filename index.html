<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‰∏ÄÂÖÉ‰∏ÄÊ¨°ÂºèÂåñÁ∞°Â§ßÊåëÊà∞</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJax for rendering Math -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            startup: {
                typeset: false // We will manually typeset
            }
        };
    </script>
    <style>
        /* Custom styles for iPad/Touch feeling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0fdf4; /* Light green bg */
            -webkit-tap-highlight-color: transparent;
            /* Prevent scrolling bounce on iOS generally, allow in specific areas */
            overflow: hidden; 
            height: 100vh;
        }
        .main-scroll-container {
            height: calc(100vh - 64px); /* Subtract header height */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .card {
            transition: all 0.3s ease;
        }
        .input-box {
            font-size: 1.1rem;
            border: 2px solid #cbd5e1;
            border-radius: 0.5rem;
            padding: 0.5rem;
            outline: none;
            transition: border-color 0.2s;
        }
        .input-box:focus {
            border-color: #22c55e;
        }
        .mjx-chtml {
            font-size: 115% !important; /* Slightly larger math for readability */
        }
        /* Canvas styles */
        #scratchpad {
            touch-action: none; /* Prevent scrolling when drawing on touch devices */
            cursor: crosshair;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px; /* Dot grid pattern */
        }
    </style>
</head>
<body class="bg-slate-50 fixed inset-0 flex flex-col">

    <!-- Header -->
    <header class="w-full bg-emerald-600 text-white p-4 shadow-md z-10 shrink-0 h-16 flex items-center">
        <div class="w-full max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center gap-2">
            <h1 class="text-xl md:text-2xl font-bold truncate">üìè ‰∏ÄÂÖÉ‰∏ÄÊ¨°ÂºèÂåñÁ∞°Á∑¥Áøí</h1>
            
            <div class="flex items-center space-x-2 bg-emerald-700 p-1 rounded-lg shrink-0">
                <button onclick="changeLevel(1)" id="btn-lvl-1" class="px-3 py-1 md:px-4 md:py-1.5 rounded-md text-sm font-medium transition-colors bg-white text-emerald-800 shadow">Âü∫Á§é</button>
                <button onclick="changeLevel(2)" id="btn-lvl-2" class="px-3 py-1 md:px-4 md:py-1.5 rounded-md text-sm font-medium transition-colors text-emerald-100 hover:bg-emerald-600">ÈÄ≤Èöé</button>
                <button onclick="changeLevel(3)" id="btn-lvl-3" class="px-3 py-1 md:px-4 md:py-1.5 rounded-md text-sm font-medium transition-colors text-emerald-100 hover:bg-emerald-600">ÊåëÊà∞</button>
            </div>
        </div>
    </header>

    <!-- Main Content Container with Scroll -->
    <div class="main-scroll-container w-full flex-grow">
        <div class="w-full max-w-7xl mx-auto p-4 flex flex-col lg:flex-row gap-6 items-start relative h-full">
            
            <!-- Left Column: Quiz Section -->
            <main class="w-full lg:w-1/2 space-y-6 pb-24" id="quiz-container">
                <!-- Questions will be injected here -->
            </main>

            <!-- Right Column: Scratchpad Section (Hidden on small screens, visible on lg+) -->
            <!-- Used sticky positioning so it stays visible while scrolling questions -->
            <aside class="w-full lg:w-1/2 bg-white rounded-xl shadow-md border border-slate-200 hidden lg:flex flex-col sticky top-4 h-[calc(100vh-100px)] overflow-hidden">
                 <div class="flex justify-between items-center p-3 border-b border-slate-100 bg-slate-50 shrink-0">
                    <h2 class="font-bold text-slate-700 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-500"><path d="M18.37 2.63 14 7l-1.59-1.59a2 2 0 0 0-2.82 0L8 7l9 9 1.59-1.59a2 2 0 0 0 0-2.82L17 10l4.37-4.37a2.12 2.12 0 1 0-3-3Z"/><path d="M9 8c-2 3-4 3.5-6 4l-2 1 1.5 1.5C4.5 16 5 18 8 20l1-2c.5-2 1-4 4-6Z"/><line x1="16" y1="10" x2="18" y2="8"/></svg>
                        Ë®àÁÆóËçâÁ®øÂçÄ
                    </h2>
                    <button onclick="clearCanvas()" class="text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-1.5 rounded transition-colors flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>
                        Ê∏ÖÁ©∫
                    </button>
                </div>
                <div class="flex-grow relative w-full p-2 bg-slate-50">
                    <canvas id="scratchpad" class="w-full h-full rounded border border-slate-200 bg-white shadow-sm"></canvas>
                </div>
            </aside>

        </div>
    </div>

    <!-- Floating Action Button for Refresh -->
    <div class="fixed bottom-6 right-6 lg:bottom-10 lg:right-10 z-20">
        <button onclick="generateNewSet()" class="bg-blue-600 hover:bg-blue-700 text-white rounded-full p-4 shadow-lg flex items-center gap-2 transition-transform transform hover:scale-105 active:scale-95">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6"/><path d="M2.5 22v-6h6"/><path d="M2 11.5a10 10 0 0 1 18.8-4.3L21.5 8"/><path d="M22 12.5a10 10 0 0 1-18.8 4.3L2.5 16"/></svg>
            <span class="font-bold hidden md:inline">Êèõ‰∏ÄÁµÑÈ°åÁõÆ</span>
        </button>
    </div>

    <script>
        // --- Quiz Logic ---
        // Game State
        let currentLevel = 1;
        let questions = [];

        // Utility: Greatest Common Divisor
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        // Utility: Fraction Class for precise calculation
        class Fraction {
            constructor(num, den = 1) {
                if (den === 0) throw new Error("Denominator cannot be zero");
                if (den < 0) { num = -num; den = -den; }
                const common = Math.abs(gcd(num, den));
                this.n = num / common;
                this.d = den / common;
            }

            add(other) {
                return new Fraction(this.n * other.d + other.n * this.d, this.d * other.d);
            }

            sub(other) {
                return new Fraction(this.n * other.d - other.n * this.d, this.d * other.d);
            }

            mul(other) {
                return new Fraction(this.n * other.n, this.d * other.d);
            }

            div(other) {
                return new Fraction(this.n * other.d, this.d * other.n);
            }

            toString() {
                if (this.d === 1) return `${this.n}`;
                return `${this.n}/${this.d}`;
            }
            
            toLatex() {
                if (this.d === 1) return `${this.n}`;
                if (this.n < 0) return `-\\frac{${Math.abs(this.n)}}{${this.d}}`;
                return `\\frac{${this.n}}{${this.d}}`;
            }

            isZero() { return this.n === 0; }
        }

        // Question Generator Logic
        function generateQuestion(level) {
            let type = 0;
            if (level === 1) type = Math.floor(Math.random() * 2) + 1;
            else if (level === 2) type = Math.floor(Math.random() * 2) + 3;
            else type = 5;
            
            if (level === 3 && Math.random() < 0.3) type = Math.floor(Math.random() * 4) + 1;

            let qText = "";
            let ansA = new Fraction(0);
            let ansB = new Fraction(0);

            const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            const nonZeroRand = (min, max) => { let r = 0; while(r===0) r = randInt(min, max); return r; };

            switch (type) {
                case 1: // 3x * (-2)
                    {
                        let c1 = nonZeroRand(-9, 9);
                        let c2 = nonZeroRand(-9, 9);
                        if(level === 1 && c2 < 0 && Math.random() > 0.5) c2 = Math.abs(c2);
                        qText = `${c1}x \\times (${c2})`;
                        ansA = new Fraction(c1 * c2);
                        ansB = new Fraction(0);
                    }
                    break;
                case 2: // (3x - 2) * 5 (Post-multiply)
                    {
                        let a = nonZeroRand(-9, 9);
                        let b = nonZeroRand(-9, 9);
                        let c = nonZeroRand(2, 9);
                        let op = b < 0 ? "-" : "+";
                        qText = `(${a}x ${op} ${Math.abs(b)}) \\times ${c}`;
                        ansA = new Fraction(a * c);
                        ansB = new Fraction(b * c);
                    }
                    break;
                case 3: // Level 2: Distributive property (Mixed signs and positions)
                    {
                        let c = Math.random() < 0.2 ? nonZeroRand(2, 9) : nonZeroRand(-9, -2);
                        let a = nonZeroRand(-9, 9);
                        let b = nonZeroRand(-9, 9);
                        let op = b < 0 ? "-" : "+";
                        let isFront = Math.random() < 0.5;

                        if (isFront) {
                            qText = `${c}(${a}x ${op} ${Math.abs(b)})`;
                        } else {
                            let cStr = c < 0 ? `(${c})` : `${c}`;
                            qText = `(${a}x ${op} ${Math.abs(b)}) \\times ${cStr}`;
                        }
                        ansA = new Fraction(c * a);
                        ansB = new Fraction(c * b);
                    }
                    break;
                case 4: // -(-2x + 1) (Negative sign removal)
                    {
                        let a = nonZeroRand(-9, 9);
                        let b = nonZeroRand(-9, 9);
                        let op = b < 0 ? "-" : "+";
                        qText = `-(${a}x ${op} ${Math.abs(b)})`;
                        ansA = new Fraction(-a);
                        ansB = new Fraction(-b);
                    }
                    break;
                case 5: // (-9x + 2) / (-2/3) (Division)
                    {
                        let numA = nonZeroRand(-10, 10);
                        let numB = nonZeroRand(-10, 10);
                        let dNum = nonZeroRand(-5, 5);
                        let dDen = randInt(2, 5);
                        let divisor = new Fraction(dNum, dDen);
                        let op = numB < 0 ? "-" : "+";
                        qText = `(${numA}x ${op} ${Math.abs(numB)}) \\div (${divisor.toLatex()})`;
                        let multiplier = new Fraction(divisor.d, divisor.n);
                        ansA = new Fraction(numA).mul(multiplier);
                        ansB = new Fraction(numB).mul(multiplier);
                    }
                    break;
            }

            return {
                id: Math.random().toString(36).substr(2, 9),
                latex: qText,
                ansA: ansA,
                ansB: ansB
            };
        }

        // Render UI
        function renderQuestions() {
            const container = document.getElementById('quiz-container');
            container.innerHTML = '';
            
            questions.forEach((q, index) => {
                const card = document.createElement('div');
                card.className = "card bg-white rounded-xl shadow-md p-6 border border-slate-200";
                
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-4">
                        <span class="bg-emerald-100 text-emerald-800 text-xs font-bold px-2 py-1 rounded">Q${index + 1}</span>
                        <div class="text-slate-400 text-xs">ÊèêÁ§∫ÔºöÁ≠îÊ°àË´ãËº∏ÂÖ•ÊúÄÁ∞°ÂΩ¢Âºè (Â¶Ç: -2/3x + 1)</div>
                    </div>
                    <div class="text-center mb-6 text-2xl text-slate-800 font-serif overflow-x-auto py-2">
                        $${q.latex}$
                    </div>
                    
                    <div class="space-y-3">
                        <div class="relative">
                            <input type="text" id="input-${q.id}" 
                                placeholder="Ëº∏ÂÖ•Á≠îÊ°à..." 
                                class="input-box w-full text-center"
                                autocomplete="off"
                                onkeypress="handleEnter(event, '${q.id}')">
                        </div>
                        
                        <button onclick="checkAnswer('${q.id}')" id="btn-${q.id}"
                            class="w-full bg-slate-800 hover:bg-slate-700 text-white font-medium py-2 px-4 rounded-lg transition-colors">
                            Ê™¢Êü•Á≠îÊ°à
                        </button>
                    </div>

                    <div id="feedback-${q.id}" class="hidden mt-4 text-center p-3 rounded-lg text-sm font-medium"></div>
                `;
                container.appendChild(card);
            });

            // Trigger MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([container]).catch((err) => console.log('MathJax rendering error:', err));
            }
        }

        // Parse Student Input (Same as before)
        function parseStudentInput(str) {
            str = str.replace(/\s+/g, '');
            if (!str) return null;
            str = str.replace(/^\+?x/, '1x'); 
            str = str.replace(/^-x/, '-1x');   
            str = str.replace(/\+x/g, '+1x');  
            str = str.replace(/-x/g, '-1x');   
            
            let coeffX = new Fraction(0);
            let constant = new Fraction(0);
            if (str[0] !== '+' && str[0] !== '-') str = '+' + str;

            const termRegex = /([+\-])(\d+(?:\/\d+)?)(x?)/g;
            let match;
            let found = false;

            while ((match = termRegex.exec(str)) !== null) {
                found = true;
                let sign = match[1] === '-' ? -1 : 1;
                let valStr = match[2];
                let isX = match[3] === 'x';
                let valParts = valStr.split('/');
                let valFrac;
                if (valParts.length === 2) valFrac = new Fraction(parseInt(valParts[0]), parseInt(valParts[1]));
                else valFrac = new Fraction(parseInt(valParts[0]));

                if (isX) {
                    if (sign === -1) valFrac = valFrac.mul(new Fraction(-1));
                    coeffX = coeffX.add(valFrac);
                } else {
                    if (sign === -1) valFrac = valFrac.mul(new Fraction(-1));
                    constant = constant.add(valFrac);
                }
            }
            if (!found) return null;
            return { a: coeffX, b: constant };
        }

        function checkAnswer(id) {
            const q = questions.find(q => q.id === id);
            const inputElem = document.getElementById(`input-${id}`);
            const feedbackElem = document.getElementById(`feedback-${id}`);
            const btnElem = document.getElementById(`btn-${id}`);
            const userStr = inputElem.value;

            const parsed = parseStudentInput(userStr);

            if (!parsed) {
                feedbackElem.className = "mt-4 text-center p-3 rounded-lg text-sm font-medium bg-yellow-100 text-yellow-800 block";
                feedbackElem.innerHTML = "‚ö†Ô∏è Ê†ºÂºè‰∏çÊ≠£Á¢∫ÔºåË´ãËº∏ÂÖ•Â¶Ç 3x+2 Êàñ -1/2x-5";
                return;
            }

            const isACorrect = parsed.a.sub(q.ansA).isZero();
            const isBCorrect = parsed.b.sub(q.ansB).isZero();

            if (isACorrect && isBCorrect) {
                feedbackElem.className = "mt-4 text-center p-3 rounded-lg text-sm font-medium bg-green-100 text-green-800 block";
                feedbackElem.innerHTML = "üéâ Á≠îÂ∞ç‰∫ÜÔºÅÂ§™Ê£í‰∫ÜÔºÅ";
                btnElem.classList.add('opacity-50', 'cursor-not-allowed');
                btnElem.disabled = true;
                inputElem.disabled = true;
            } else {
                feedbackElem.className = "mt-4 text-center p-3 rounded-lg text-sm font-medium bg-red-100 text-red-800 block";
                let ansStr = "";
                if (!q.ansA.isZero()) ansStr += `$${q.ansA.toLatex()}x$`;
                if (!q.ansB.isZero()) {
                    let termB = q.ansB.toLatex();
                    if(q.ansB.n > 0 && q.ansA.isZero()) ansStr += termB; 
                    else if(q.ansB.n < 0) ansStr += ` $${termB}$`; 
                    else if(q.ansB.n > 0) ansStr += ` $${termB}$`; 
                }
                if (ansStr === "") ansStr = "0";
                feedbackElem.innerHTML = `‚ùå Á≠îÊ°à‰∏çÊ≠£Á¢∫„ÄÇ<br>Ê≠£Á¢∫Á≠îÊ°àÊòØÔºö${ansStr}`;
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([feedbackElem]);
                }
            }
        }

        function handleEnter(e, id) {
            if (e.key === 'Enter') checkAnswer(id);
        }

        function changeLevel(lvl) {
            currentLevel = lvl;
            [1, 2, 3].forEach(i => {
                const btn = document.getElementById(`btn-lvl-${i}`);
                if (i === lvl) btn.className = "px-3 py-1 md:px-4 md:py-1.5 rounded-md text-sm font-medium transition-colors bg-white text-emerald-800 shadow";
                else btn.className = "px-3 py-1 md:px-4 md:py-1.5 rounded-md text-sm font-medium transition-colors text-emerald-100 hover:bg-emerald-600";
            });
            generateNewSet();
        }

        function generateNewSet() {
            questions = [];
            for (let i = 0; i < 3; i++) {
                questions.push(generateQuestion(currentLevel));
            }
            renderQuestions();
        }

        // --- Scratchpad Logic ---
        const canvas = document.getElementById('scratchpad');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        function resizeCanvas() {
            // Make canvas drawing buffer size match its display size
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Only resize if dimensions have changed distinctively to avoid clear on mobile scroll
            if (Math.abs(canvas.width - rect.width) > 5 || Math.abs(canvas.height - rect.height) > 5) {
                 // Save current content
                 const tempCanvas = document.createElement('canvas');
                 tempCanvas.width = canvas.width;
                 tempCanvas.height = canvas.height;
                 const tempCtx = tempCanvas.getContext('2d');
                 if (canvas.width > 0 && canvas.height > 0) tempCtx.drawImage(canvas, 0, 0);

                 // Resize
                 canvas.width = rect.width;
                 canvas.height = rect.height;

                 // Restore content
                 if (tempCanvas.width > 0 && tempCanvas.height > 0 && canvas.width > 0) {
                    ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, canvas.width, canvas.height);
                 }

                 // Reset line styles
                 ctx.strokeStyle = '#334155'; // slate-700
                 ctx.lineJoin = 'round';
                 ctx.lineCap = 'round';
                 ctx.lineWidth = 2.5;
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            // Prevent default only if target is canvas to allow scrolling elsewhere
            if (e.cancelable && e.target === canvas) e.preventDefault();

            let clientX, clientY;
            if(e.type.includes('touch')) {
                if (e.touches.length === 0) return;
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            [lastX, lastY] = [x, y];
        }

        function startDrawing(e) {
            isDrawing = true;
            let clientX, clientY;
             if(e.type.includes('touch')) {
                 if (e.touches.length === 0) return;
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            const rect = canvas.getBoundingClientRect();
            [lastX, lastY] = [clientX - rect.left, clientY - rect.top];
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Event Listeners for Drawing
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        // --- Initialization ---
        // Use window load to ensure MathJax and layout are ready
        window.addEventListener('load', () => {
            // 1. Initialize Canvas size
            resizeCanvas();
            
            // 2. Generate first set of questions (this will trigger MathJax rendering)
            generateNewSet();
        });

        // Resize canvas when window resizes (e.g. rotating iPad)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 200); // Debounce resize
        });

    </script>
</body>
</html>